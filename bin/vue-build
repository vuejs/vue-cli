#!/usr/bin/env node

var fs = require('fs')
var path = require('path')
var program = require('commander')
var chalk = require('chalk')
var rm = require('rimraf').sync
var webpack = require('webpack')
var Server = require('webpack-dev-server')
var webpackMerge = require('webpack-merge')
var HtmlWebpackPlugin = require('html-webpack-plugin')
var FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')
var PostCompilePlugin = require('post-compile-webpack-plugin')
var ProgressPlugin = require('webpack/lib/ProgressPlugin')
var ExtractTextPlugin = require('extract-text-webpack-plugin')
var isYarn = require('installed-by-yarn-globally')
var loaders = require('../lib/loaders')
var logger = require('../lib/logger')

/**
 * Usage.
 */

program
  .usage('[entry]')
  .option('--dist [directory]', 'Output directory for bundled files', 'dist')
  .option('--port [port]', 'Server port', 4000)
  .option('--host [host]', 'Server host', 'localhost')
  .option('--prod, --production', 'Build for production', false)
  .option('-c, --config [directory]', 'Use custom config directory')
  .option('--no-config', 'You do not want global and local config')
  .option('-o, --open', 'Open browser')
  .parse(process.argv)

var args = program.args
var production = program.production

process.env.NODE_ENV = production ? 'production' : 'development'

// load config and webpack config from $config/.vue
var configContext = typeof program.config === 'string' ? process.cwd() : require('user-home')
var configDirectory = typeof program.config === 'string' ? program.config : '.vue'
var localConfigPath = path.join(configContext, configDirectory, 'config.js')
var localWebpackConfigPath = path.join(configContext, configDirectory, 'webpack.config.js')
var localConfig
var localWebpackConfig

if (program.config !== false) {
  var hasLocalConfig = fs.existsSync(localConfigPath)
  var hasLocalWebpackConfig = fs.existsSync(localWebpackConfigPath)
  if (hasLocalConfig) {
    localConfig = require(localConfigPath)
  }
  if (hasLocalWebpackConfig) {
    localWebpackConfig = require(localWebpackConfigPath)
  }
}

var options = Object.assign({}, localConfig, {
  entry: args[0] || 'index.js',
  port: program.port,
  host: program.host,
  open: program.open,
  dist: program.dist
})

var cssOptions = {
  extract: production,
  sourceMap: true
}

var postcssOptions = {
  plugins: [
    require('autoprefixer')(Object.assign({
      browsers: ['ie > 8', 'last 5 versions']
    }, options.autoprefixer))
  ]
}

if (options.postcss) {
  if (Object.prototype.toString.call(options.postcss) === '[object Object]') {
    var plugins = options.postcss.plugins
    if (plugins) {
      postcssOptions.plugins = postcssOptions.plugins.concat(plugins)
      delete options.postcss.plugins
    }
    Object.assign(postcssOptions, options.postcss)
  } else {
    postcssOptions = options.postcss
  }
}

var webpackConfig = {
  entry: {
    client: []
  },
  output: {
    path: path.join(process.cwd(), options.dist),
    filename: production ? '[name].[chunkhash:8].js' : '[name].js',
    publicPath: '/'
  },
  performance: {
    hints: false
  },
  resolve: {
    extensions: ['.js', '.vue', '.css'],
    modules: [
      process.cwd(),
      path.join(process.cwd(), 'node_modules'), // modules in cwd's node_modules
      path.join(__dirname, '../node_modules') // modules in package's node_modules
    ],
    alias: {}
  },
  resolveLoader: {
    modules: [
      path.join(process.cwd(), 'node_modules'), // loaders in cwd's node_modules
      path.join(__dirname, '../node_modules') // loaders in package's node_modules
    ]
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: 'buble-loader',
        exclude: [/node_modules/]
      },
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: {
          postcss: postcssOptions,
          loaders: Object.assign({
            js: 'buble-loader'
          }, loaders.cssLoaders(cssOptions))
        }
      },
      {
        test: /\.(ico|jpg|png|gif|svg|eot|otf|webp|ttf|woff|woff2)(\?.*)?$/,
        loader: 'file-loader',
        query: {
          name: 'static/[name].[hash:8].[ext]'
        }
      }
    ].concat(loaders.styleLoaders(cssOptions))
  },
  plugins: [
    new HtmlWebpackPlugin(Object.assign({
      title: 'Vue App',
      template: path.join(__dirname, '../lib/template.html')
    }, options.html)),
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)
    }),
    new webpack.LoaderOptionsPlugin({
      options: {
        context: process.cwd(),
        postcss: postcssOptions,
        buble: {
          objectAssign: 'Object.assign',
          transforms: {
            dangerousForOf: false,
            modules: false
          }
        }
      }
    })
  ]
}

if (/\.vue$/.test(options.entry) || options.component) {
  webpackConfig.entry.client.push(path.join(__dirname, '../lib/default-entry'))
  webpackConfig.resolve.alias['your-tasteful-component'] = options.entry
} else {
  webpackConfig.entry.client.push(options.entry)
}

// installed by `yarn global add`
if (isYarn(__dirname)) {
  // modules in yarn global node_modules
  // becuase of yarn's flat node_modules structure
  webpackConfig.resolve.modules.push(path.join(__dirname, '../../'))
  // loaders in yarn global node_modules
  webpackConfig.resolveLoader.modules.push(path.join(__dirname, '../../'))
}

if (production) {
  webpackConfig.devtool = 'source-map'
  webpackConfig.plugins.push(
    new ProgressPlugin(),
    new webpack.optimize.UglifyJsPlugin({
      sourceMap: true,
      compressor: {
        warnings: false
      },
      output: {
        comments: false
      }
    }),
    new webpack.LoaderOptionsPlugin({
      minimize: true
    }),
    new ExtractTextPlugin('[name].[contenthash:8].css')
  )
} else {
  webpackConfig.devtool = 'eval-source-map'
  webpackConfig.entry.client.push(
    require.resolve('webpack-dev-server/client'),
    require.resolve('webpack/hot/dev-server')
  )
  webpackConfig.plugins.push(
    new webpack.HotModuleReplacementPlugin(),
    new FriendlyErrorsPlugin(),
    new PostCompilePlugin(() => {
      console.log(`> Open http://${options.host}:${options.port}`)
    })
  )
}

// apply custom webpack config
if (localWebpackConfig) {
  // modules in config directory's node_modules
  webpackConfig.resolve.modules.push(path.join(configContext, configDirectory))
  // loaders in config directory's node_modules
  webpackConfig.resolveLoader.modules.push(path.join(configContext, configDirectory, 'node_modules'))
  webpackConfig = webpackMerge(webpackConfig, localWebpackConfig)
}

// directly mutate webpackConfig
if (typeof options.webpack === 'function') {
  webpackConfig = options.webpack(webpackConfig, options, webpack)
}

var compiler = webpack(webpackConfig)

checkEntryExists(options.entry)

if (production) {
  // remove dist files but keep that folder in production mode
  rm(path.join(options.dist, '*'))
  compiler.run((err, stats) => {
    if (err) {
      process.exitCode = 1
      return console.error(err.stack)
    }
    if (stats.hasErrors() || stats.hasWarnings()) {
      process.exitCode = 1
      return console.error(stats.toString('errors-only'))
    }
    console.log(stats.toString({
      chunks: false,
      children: false,
      modules: false,
      colors: true
    }))
  })
} else {
  var server = new Server(compiler, Object.assign({
    quiet: true,
    hot: true,
    inline: true
  }, localWebpackConfig && localWebpackConfig.devServer))

  server.listen(options.port, options.host)
  if (options.open) {
    require('opn')(`http://${options.host}:${options.port}`)
  }
}

function checkEntryExists (entry) {
  if (!fs.existsSync(entry)) {
    logger.fatal(`${chalk.yellow(entry)} does not exist, did you forget to create one?`)
  }
}
